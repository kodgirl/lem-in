5.06.2020
-Внёс изменение в код, введя новую переменную in_way, чтобы комнаты, которые уже один раз использовались в пути кроме
первого и последнего, больше не вносились в bfs очередь.
-Внёс костыль, который решает задачу, когда есть только две комнаты и между ними проходят муравьи. Это как особый случай.
??? Внёс изменение в код по добавлению рёбер. Теперь новые рёбра будут добавляться не к концу, а к началу.
??? Убрал функцию invert. Теперь новые комнаты в record вносятся не в конец списка, а в её начало. Так намного меньше
итераций.
Немного о себе:
Почему так тяжело эмоционально откатывать проект?

Полностью переписываю проект, чтобы расставить все функции более
упорядочено с целью облегчить редактирование.
//////////////////
Итак. Переписываю функции заново, расставляя более упорядочено
все переменные в структурах данных.
Сейчас перезаписываю функции очистки данных для повторного запуска
bfs.
Все функции очистки необходимо перевести в новый файл.
Если и дальше будет возникать проблема с печатью, то
в отдельном файле всё переведу в массивы и сделаю решение на них.
Моя задача сейчас это построить систему без раздвоения комнат.
Простой поиск путей и перемещение как у Саши.
Сделать печать строк равномерной.
Проверить на карты от нуля до больших карт. Большие карты через гене
ратор.
Важно все отдельные по смыслу операции совершать в отдельных файлах
для облегчения редактирования кода.
Все новые файлы находятся на ветке rewrite_project.
//////////////////////
08.06.
Создал новый файл clear_marks, где очищаются отмеченны
Написал функцию, которая отмечает рёбра, использованные в пути.
Перестал работать правильно bfs, т.к. находит иной путь.
BFS нормально работает, внёс изменение, чтоб если нашёл путь и дальше движется,
то не должен обновлять указатель последней комнаты go_from.
Сейчас вопрос в том, что выделяется лишняя комната, когда найденный путь выделяю
в отдельный лист. - Решил этот вопрос. Дело в том, что записывается путь в листы
путём добавления комнат в начало, а не в конец, чтобы потом не разворачивать
комнату обратно. Поэтому последняя комната указывала на нулевую комнату, а теперь
этой комнаты нет.
Сейчас находит все прямые пути и заканчивает путь, когда уже нечего из путей возвращать.
Все пути находятся в переменной all_ways.
Сейчас думаю ввести новую функцию, которая переведёт все пути в массивы, чтобы
легче было передвигать муравьев.
-Перевёл все пути в массивы, но ещё не освободил память путей в листах.
Буду позже освобождать все структуры полностью.
-Не записывает вычисления для второй комнаты.
-Почему-то путь в листах теряется, когда доходит решения. Дело в том, что я их
забыл записывать в структуру путей.

09/06
Продолжаю писать часть решения задачи.
-Начинаю писать код по перемещению. Первое условие - если у нас есть две вершины в пути.
Тогда в одном нужно не обнулять муравья, а убавлять, а последней комнате не присваивать,
а прибавлять.
-Выводится ошибка сигсев. Это случается именно когда запускаю третьего муравья.
Указывает, что той второй комнаты в пути нет, куда в первый раз уже запускался муравей.
Решил. Причина была в неверном указателе. Указал вообще на комнату, вместо указателя её муравья.
-Сейчас неправильно выводится карта maps/valid/three_ways. 4-ый муравей идёт достаточно долго отдельно
тем самым увеличив число новых строк. Вообще вывод отличается от других студентов.
Следует тщательно отследить путь 4-го муравья. Проблема заключается в поиске путей.
Сейчас выведу все найденные пути. Находит программа разные пути. Моя программа находит четыре пути.
? Находит разные пути
? Калькуляция необходимости ввода нового пути высчитывает 3, а у других 31.
Начну отслеживать работу bfs. Первый найденный путь совпадает, но второй путь у меня начинается с 0-6,
а у других с 0-66.
Я изменил условие цикла запуска путей, в котором не все пути поддаются для двжения муравьёв и обнаружил,
что программа сработала отлично. Но тем самым программа перестанет работать, если будет найден только 2 пути.
Поэтому следует узнать как именно следует делать вычисления, чтобы лишние большие пути выкидывались, а необходимые
остались. Моя калькуляция определённо работает не так, как должна. Поэтому следует ещё более глубоко изучить
чужую калькуляцию, чтобы согласно правилу распределять муравьёв равномерно.
Например, при карте test.map обычно путь X-Y-Z не пользуется, а в моём используется.
Соответственно, есть два актуальных вопроса:
1. Почему мой bfs находит в больших картах разные пути по сравнению с необходимым.
2. Как именно должна совершаться калькуляция путей.
Чтобы это понять, следует сначала посмотреть на калькуляцию и подробно с комментариями её изучить.
Далее взяться на bfs и отслеживать поиск каждого нового пути через debugger, начиная со второго пути.
Мой алгоритм ищет все пути и записывает.
Я полагал, что его алгоритм выкидывает неэффективные пути. Но его алгоритм реально находит вторым путём 0-66, а мой 0-6.
Значит надо исследовать bfs пошагово. Сегодня проработал 2 часа, 38 минут.
У него bfs работает по-иному, т.к. у него идёт поиск по уровням, а не по указателю на прошлую
комнату.
Если берём карту test.map, то увидим, что найдя путь A-C-E-F, он обратно вернётся через F-D-C-A, Т.Е. A-C-D-F,
потому что Е и D находятся на одном уровне. Соответственно и пути находятся разные.
А вот почему он ещё находит третий путь, который до конца толком не записан от начала до конца, а лишь урывками - вопрос.
Ответ таков, что обрезает, так как когда хочет добавить путь A-B-D-C-E-F, то уже С и D используются в первом
и втором пути, поэтому их не добавляет в новый путь.
В карте difficult/three_ways последний муравей еле доходит.
Итак. Чтобы лучше понимать насколько хорош мой код - следует запускать тесты.
А начальные тесты не проходят до конца. Поэтому сначала приведу код в порядок, чтобы отрабатывал на
ошибочные тесты. А затем возьмусь за дальнейшее улучшение решения поиска путей.

ОШИБКИ
1. Когда подаётся неправильно кол-во муравьёв, то это отмечается в переменной error.
В дальнейшем его значение ошибки муравья 1, меняется на другой код ошибки - парсинга комнат.
3 тайм пошёл.
Думаю делать проверку на количество путей. Когда найдет более 2 путей, то последний путь удалить.
Это костыль, который поможет избавиться от некорректного вывода.((((
2. Количество строк больше, чем положено. На тысячу путей должен выводить 29 строк, а выводит 59.
Изучить подробнее как найти лучшие пути, чтобы сократить количество строк вывода.
На 1 муравья - 35 вместо 33
На 10 муравьёв - 34 вместо 31.
На 100 муравьёв - 50 вместо 30.
На big карте - 173 вместо 78.
На super-big - 124 вместо 75.

Раз у меня больше линий выходит даже при одном пути, значит у меня проблема есть не просто в алгоритме поиска путей,
а ещё и в перемещении муравьёв.
Узнай, как лучше перемещать муравьёв.
Выяснилось, что что-то не так с калькуляцией путей. У других запускает сразу на 4-х путях, а у меня только на трёх.
Будем смотреть как выводит калькуляцию у меня и у других.
!У меня на четвёртой итерации калькуляция идёт отрицательная. А у остальных продолжается.
Попробуй разобрать с комментариями и применить потом у себя.
!А также заменить все ft_printf на ft_putstr и ft_putchar.

Ошибка при отсутствии комнаты.
Убрал лишний пробел перед ERROR.
Проверяю ошибочные карты на утечку памяти.
Выводит ошибку, когда имена комнат дублируются. Скорее всего причина состоит в подборе рёбер для каждой комнаты.
Решил тем, что если встречается ошибка, то переходит в новую функцию, печатает все строки. После печати всех строк
очищает всю выделенную память и выходит.
!Есть утечка памяти, когда есть # в названии комнаты. Правильно выводит ошибку, но утекает память.
Хочу поменять. Если есть в тексте ##start или #end, то парсит следующую комнату. А иначе тупо пропускает.
Всё расставил обратно по местам. Выделяется лишняя память в той части, где проверяется комната ли это.
При проверке чере сплит память была выделена, т.к. эта строка входила в норму 3 аргуметов через пробел.
Далее её отправили на запись комнаты. Решил эту проблему. Она оказалась в том, что выделяется память под сплит. Но
когда обнаруживается, что в ней есть хеш, то не очищается этот Сплит, программа продолжает очищать только одну строку.
Установил ещё один критерий при парсинге комнат - если в ней не 3 символа ИЛИ в ней есть хеш, то это не комната, очищай
сплит.

Сейчас приступаю к дебагингу карты с одним путём и тысячным, котоырй выводит неопределённую ошибку.
Ошибка появляется по причине неправильной очистки. По крайне мере именно этот кусок очистки памяти влияет на ответ.
Решил освобождать пути в листах сразу тогда, когда перевожу пути в массив. Однако в таком случае при повторном запуске
bfs выходит ошибка памяти, т.к. я использую листы путей для отметки использованных вершин и рёбер.